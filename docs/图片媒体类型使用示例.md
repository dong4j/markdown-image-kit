# ImageMediaType 使用示例

## 快速开始

### 基本用法

```java
import info.dong4j.idea.plugin.enums.ImageMediaType;

// 1. 通过 Content-Type 获取枚举
ImageMediaType type = ImageMediaType.fromContentType("image/jpeg");
System.out.println(type.getExtension());  // 输出: .jpg

// 2. 通过扩展名获取枚举
ImageMediaType type = ImageMediaType.fromExtension(".png");
System.out.println(type.getContentType());  // 输出: image/png

// 3. 直接转换：Content-Type -> 扩展名
String ext = ImageMediaType.getExtensionByContentType("image/webp");
System.out.println(ext);  // 输出: .webp

// 4. 直接转换：扩展名 -> Content-Type
String contentType = ImageMediaType.getContentTypeByExtension(".gif");
System.out.println(contentType);  // 输出: image/gif

// 5. 获取不包含点号的扩展名
ImageMediaType type = ImageMediaType.PNG;
String extWithoutDot = type.getExtensionWithoutDot();
System.out.println(extWithoutDot);  // 输出: png

// 6. Content-Type -> 不包含点号的扩展名
String ext = ImageMediaType.getExtensionWithoutDotByContentType("image/jpeg");
System.out.println(ext);  // 输出: jpg

// 7. 标准化扩展名（不含点号）
String standardExt = ImageMediaType.getStandardExtensionWithoutDot(".jpeg");
System.out.println(standardExt);  // 输出: jpg (标准化为 jpg)
```

## 实际应用场景

### 场景 1: 下载网络图片时确定扩展名

```java
public class ImageDownloader {
    public File downloadImage(String url) throws IOException {
        URLConnection connection = new URL(url).openConnection();
        String contentType = connection.getContentType();
        
        // 从 Content-Type 获取扩展名
        String extension = ImageMediaType.getExtensionByContentType(contentType);
        
        if (extension == null) {
            // 无法识别，使用默认扩展名
            extension = ".png";
        }
        
        // 生成文件名
        String filename = UUID.randomUUID().toString() + extension;
        File outputFile = new File("downloads", filename);
        
        // 下载文件...
        return outputFile;
    }
}
```

### 场景 2: 上传文件前验证类型

```java
public class FileValidator {
    private static final Set<ImageMediaType> ALLOWED_TYPES = Set.of(
        ImageMediaType.JPEG,
        ImageMediaType.PNG,
        ImageMediaType.GIF,
        ImageMediaType.WEBP
    );
    
    public boolean isValidImageFile(String filename) {
        // 从文件名提取扩展名
        int dotIndex = filename.lastIndexOf('.');
        if (dotIndex < 0) {
            return false;
        }
        
        String extension = filename.substring(dotIndex);
        ImageMediaType type = ImageMediaType.fromExtension(extension);
        
        // 检查是否是允许的类型
        return type != null && ALLOWED_TYPES.contains(type);
    }
    
    public String getValidationMessage(String filename) {
        ImageMediaType type = ImageMediaType.fromExtension(
            filename.substring(filename.lastIndexOf('.'))
        );
        
        if (type == null) {
            return "不支持的文件格式";
        }
        
        if (!ALLOWED_TYPES.contains(type)) {
            return String.format("不允许上传 %s 格式的图片", type.name());
        }
        
        return "文件格式有效";
    }
}
```

### 场景 3: HTTP 响应头设置

```java
public class ImageController {
    @GetMapping("/images/{filename}")
    public ResponseEntity<byte[]> serveImage(@PathVariable String filename) throws IOException {
        File imageFile = new File("images", filename);
        byte[] imageBytes = Files.readAllBytes(imageFile.toPath());
        
        // 从文件名获取 Content-Type
        String extension = filename.substring(filename.lastIndexOf('.'));
        String contentType = ImageMediaType.getContentTypeByExtension(extension);
        
        if (contentType == null) {
            contentType = "application/octet-stream";
        }
        
        return ResponseEntity.ok()
            .contentType(MediaType.parseMediaType(contentType))
            .body(imageBytes);
    }
}
```

### 场景 4: 文件格式转换

```java
public class ImageConverter {
    public File convertImage(File sourceFile, ImageMediaType targetFormat) throws IOException {
        // 验证源文件格式
        String sourceExt = sourceFile.getName().substring(sourceFile.getName().lastIndexOf('.'));
        ImageMediaType sourceFormat = ImageMediaType.fromExtension(sourceExt);
        
        if (sourceFormat == null) {
            throw new IllegalArgumentException("不支持的源文件格式: " + sourceExt);
        }
        
        // 读取源文件
        BufferedImage image = ImageIO.read(sourceFile);
        
        // 生成目标文件名
        String baseName = sourceFile.getName().substring(0, sourceFile.getName().lastIndexOf('.'));
        String targetFilename = baseName + targetFormat.getExtension();
        File targetFile = new File(sourceFile.getParent(), targetFilename);
        
        // 根据目标格式写入文件（使用不含点号的扩展名）
        String formatName = targetFormat.getExtensionWithoutDot();
        ImageIO.write(image, formatName, targetFile);
        
        return targetFile;
    }
    
    // 使用示例
    public void example() throws IOException {
        File pngFile = new File("image.png");
        File webpFile = convertImage(pngFile, ImageMediaType.WEBP);
        System.out.println("转换完成: " + webpFile.getPath());
    }
}
```

### 场景 5: 批量处理图片

```java
public class ImageProcessor {
    public Map<ImageMediaType, List<File>> groupImagesByType(List<File> files) {
        Map<ImageMediaType, List<File>> grouped = new HashMap<>();
        
        for (File file : files) {
            String filename = file.getName();
            int dotIndex = filename.lastIndexOf('.');
            
            if (dotIndex < 0) {
                continue; // 跳过没有扩展名的文件
            }
            
            String extension = filename.substring(dotIndex);
            ImageMediaType type = ImageMediaType.fromExtension(extension);
            
            if (type != null) {
                grouped.computeIfAbsent(type, k -> new ArrayList<>()).add(file);
            }
        }
        
        return grouped;
    }
    
    public void printStatistics(List<File> files) {
        Map<ImageMediaType, List<File>> grouped = groupImagesByType(files);
        
        System.out.println("图片格式统计:");
        grouped.forEach((type, fileList) -> {
            long totalSize = fileList.stream()
                .mapToLong(File::length)
                .sum();
            
            System.out.printf("  %s (%s): %d 个文件, 总大小: %d KB%n",
                type.name(),
                type.getContentType(),
                fileList.size(),
                totalSize / 1024);
        });
    }
}
```

### 场景 6: 处理 HTTP 请求中的 Content-Type

```java
public class UploadHandler {
    public void handleUpload(InputStream inputStream, String contentType, String originalFilename) {
        // 方式 1: 优先使用 Content-Type
        String extension = ImageMediaType.getExtensionByContentType(contentType);
        
        // 方式 2: Content-Type 不可靠时，从文件名推断
        if (extension == null && originalFilename != null) {
            int dotIndex = originalFilename.lastIndexOf('.');
            if (dotIndex >= 0) {
                String fileExt = originalFilename.substring(dotIndex);
                ImageMediaType type = ImageMediaType.fromExtension(fileExt);
                if (type != null) {
                    extension = type.getExtension();
                }
            }
        }
        
        // 方式 3: 都不可靠时，使用默认扩展名
        if (extension == null) {
            extension = ".png";
        }
        
        // 保存文件
        String filename = UUID.randomUUID().toString() + extension;
        File outputFile = new File("uploads", filename);
        
        try (FileOutputStream out = new FileOutputStream(outputFile)) {
            inputStream.transferTo(out);
        } catch (IOException e) {
            throw new RuntimeException("保存文件失败", e);
        }
    }
}
```

### 场景 7: 生成合适的 MIME 类型列表

```java
public class ImageUploadConfig {
    /**
     * 获取允许上传的图片格式的 Content-Type 列表
     */
    public static List<String> getAllowedContentTypes() {
        return Arrays.asList(
            ImageMediaType.JPEG.getContentType(),
            ImageMediaType.PNG.getContentType(),
            ImageMediaType.GIF.getContentType(),
            ImageMediaType.WEBP.getContentType()
        );
    }
    
    /**
     * 获取允许上传的文件扩展名列表
     */
    public static List<String> getAllowedExtensions() {
        return Arrays.asList(
            ImageMediaType.JPEG.getExtension(),
            ImageMediaType.PNG.getExtension(),
            ImageMediaType.GIF.getExtension(),
            ImageMediaType.WEBP.getExtension()
        );
    }
    
    /**
     * 生成 HTML5 文件输入框的 accept 属性
     */
    public static String getHtmlAcceptAttribute() {
        return getAllowedContentTypes().stream()
            .collect(Collectors.joining(","));
    }
}

// 使用示例
// <input type="file" accept="image/jpeg,image/png,image/gif,image/webp">
```

### 场景 8: 使用不含点号的扩展名

```java
public class ImageIOWrapper {
    /**
     * 保存图片到文件
     * ImageIO.write() 需要格式名称（不含点号），如 "png", "jpg"
     */
    public void saveImage(BufferedImage image, File file, ImageMediaType format) throws IOException {
        // 使用不含点号的扩展名作为格式名
        String formatName = format.getExtensionWithoutDot();
        boolean success = ImageIO.write(image, formatName, file);
        
        if (!success) {
            throw new IOException("没有找到适合 " + formatName + " 格式的 ImageWriter");
        }
    }
    
    /**
     * 从 URL 下载图片并保存
     */
    public File downloadAndSave(String imageUrl, String contentType) throws IOException {
        // 从 Content-Type 获取不含点号的扩展名
        String extension = ImageMediaType.getExtensionWithoutDotByContentType(contentType);
        
        if (extension == null) {
            extension = "png"; // 默认格式
        }
        
        // 生成文件名
        String filename = UUID.randomUUID().toString() + "." + extension;
        File outputFile = new File("downloads", filename);
        
        // 下载并保存...
        URLConnection connection = new URL(imageUrl).openConnection();
        BufferedImage image = ImageIO.read(connection.getInputStream());
        
        // 使用扩展名保存（ImageIO.write 需要不含点号的格式名）
        ImageIO.write(image, extension, outputFile);
        
        return outputFile;
    }
    
    /**
     * 标准化文件扩展名
     * 将各种别名转换为标准扩展名（不含点号）
     */
    public String standardizeExtension(String filename) {
        int dotIndex = filename.lastIndexOf('.');
        if (dotIndex < 0) {
            return null;
        }
        
        String ext = filename.substring(dotIndex);
        // 使用枚举标准化扩展名（例如 .jpeg -> jpg）
        return ImageMediaType.getStandardExtensionWithoutDot(ext);
    }
    
    // 使用示例
    public void example() {
        // .jpeg -> jpg
        String standardExt = standardizeExtension("photo.jpeg");
        System.out.println(standardExt); // 输出: jpg
        
        // .JPEG -> jpg (大小写不敏感)
        standardExt = standardizeExtension("photo.JPEG");
        System.out.println(standardExt); // 输出: jpg
        
        // .png -> png
        standardExt = standardizeExtension("image.png");
        System.out.println(standardExt); // 输出: png
    }
}
```

### 场景 9: 错误处理和日志记录

```java
public class ImageLogger {
    private static final Logger log = LoggerFactory.getLogger(ImageLogger.class);
    
    public void logImageInfo(String filename, String contentType) {
        ImageMediaType typeByFilename = null;
        ImageMediaType typeByContentType = null;
        
        // 从文件名推断
        int dotIndex = filename.lastIndexOf('.');
        if (dotIndex >= 0) {
            typeByFilename = ImageMediaType.fromExtension(filename.substring(dotIndex));
        }
        
        // 从 Content-Type 推断
        typeByContentType = ImageMediaType.fromContentType(contentType);
        
        // 检查是否一致
        if (typeByFilename != null && typeByContentType != null) {
            if (typeByFilename == typeByContentType) {
                log.info("文件 {} 类型一致: {}", filename, typeByFilename.name());
            } else {
                log.warn("文件 {} 类型不一致! 文件名: {}, Content-Type: {}", 
                    filename, 
                    typeByFilename.name(), 
                    typeByContentType.name());
            }
        } else if (typeByFilename == null && typeByContentType == null) {
            log.error("无法识别文件 {} 的类型", filename);
        } else if (typeByFilename == null) {
            log.warn("文件 {} 的扩展名无法识别，但 Content-Type 是 {}", 
                filename, 
                typeByContentType.name());
        } else {
            log.warn("文件 {} 的 Content-Type 无法识别，但扩展名是 {}", 
                filename, 
                typeByFilename.name());
        }
    }
}
```

## 处理边界情况

### 1. 处理 null 值

```java
// ✅ 好的做法：使用 Optional
String extension = Optional.ofNullable(
    ImageMediaType.getExtensionByContentType(contentType)
).orElse(".png");

// ✅ 好的做法：显式检查
String extension = ImageMediaType.getExtensionByContentType(contentType);
if (extension == null) {
    extension = ".png";
}

// ❌ 不好的做法：可能导致 NullPointerException
String extension = ImageMediaType.getExtensionByContentType(contentType);
System.out.println(extension.length()); // 可能抛出异常
```

### 2. 处理未知格式

```java
public String getExtensionSafely(String filename) {
    int dotIndex = filename.lastIndexOf('.');
    if (dotIndex < 0) {
        return ".png"; // 没有扩展名，使用默认
    }
    
    String fileExt = filename.substring(dotIndex);
    ImageMediaType type = ImageMediaType.fromExtension(fileExt);
    
    if (type != null) {
        return type.getExtension(); // 返回标准扩展名
    } else {
        return fileExt.toLowerCase(); // 保留原扩展名（小写）
    }
}
```

### 3. 处理扩展名别名

```java
// 以下所有调用都返回 ImageMediaType.JPEG
ImageMediaType type1 = ImageMediaType.fromExtension(".jpg");
ImageMediaType type2 = ImageMediaType.fromExtension(".jpeg");
ImageMediaType type3 = ImageMediaType.fromExtension(".jfif");
ImageMediaType type4 = ImageMediaType.fromExtension(".pjpeg");

// 它们的标准扩展名都是 ".jpg"
System.out.println(type1.getExtension()); // .jpg
System.out.println(type2.getExtension()); // .jpg
System.out.println(type3.getExtension()); // .jpg
System.out.println(type4.getExtension()); // .jpg
```

## 性能考虑

### 缓存枚举查找结果

如果需要频繁查找同一个 Content-Type 或扩展名：

```java
public class CachedImageMediaType {
    private static final Map<String, ImageMediaType> CONTENT_TYPE_CACHE = new ConcurrentHashMap<>();
    private static final Map<String, ImageMediaType> EXTENSION_CACHE = new ConcurrentHashMap<>();
    
    public static ImageMediaType fromContentTypeCached(String contentType) {
        return CONTENT_TYPE_CACHE.computeIfAbsent(
            contentType, 
            ImageMediaType::fromContentType
        );
    }
    
    public static ImageMediaType fromExtensionCached(String extension) {
        return EXTENSION_CACHE.computeIfAbsent(
            extension, 
            ImageMediaType::fromExtension
        );
    }
}
```

注意：对于大多数场景，直接使用枚举方法已经足够快，不需要额外的缓存。

## 测试示例

```java
@Test
public void testImageMediaTypeConversion() {
    // 测试 Content-Type -> 扩展名
    assertEquals(".jpg", ImageMediaType.getExtensionByContentType("image/jpeg"));
    assertEquals(".png", ImageMediaType.getExtensionByContentType("image/png"));
    assertEquals(".webp", ImageMediaType.getExtensionByContentType("image/webp"));
    
    // 测试扩展名 -> Content-Type
    assertEquals("image/jpeg", ImageMediaType.getContentTypeByExtension(".jpg"));
    assertEquals("image/png", ImageMediaType.getContentTypeByExtension("png"));
    assertEquals("image/webp", ImageMediaType.getContentTypeByExtension(".webp"));
    
    // 测试别名处理
    assertEquals(ImageMediaType.JPEG, ImageMediaType.fromExtension(".jpeg"));
    assertEquals(ImageMediaType.JPEG, ImageMediaType.fromExtension(".jfif"));
    
    // 测试未知类型
    assertNull(ImageMediaType.fromExtension(".unknown"));
    assertNull(ImageMediaType.getContentTypeByExtension(".xyz"));
    
    // 测试 Content-Type 参数处理
    assertEquals(".jpg", ImageMediaType.getExtensionByContentType("image/jpeg; charset=utf-8"));
}
```

## 常见问题

### Q: 为什么 `.jpeg` 会被转换为 `.jpg`？

A: 这是为了标准化扩展名。虽然 `.jpeg` 和 `.jpg` 都是有效的，但我们选择 `.jpg` 作为标准扩展名，因为它更短且更常用。

### Q: 如果我需要保留原始扩展名怎么办？

A: 如果需要保留原始扩展名，建议在调用枚举方法之前先保存原始值，然后根据业务需求决定使用哪个。

```java
String originalExt = filename.substring(filename.lastIndexOf('.'));
ImageMediaType type = ImageMediaType.fromExtension(originalExt);
String standardExt = type != null ? type.getExtension() : originalExt;

// 根据需求选择使用 originalExt 还是 standardExt
```

### Q: 枚举方法是线程安全的吗？

A: 是的，所有枚举方法都是线程安全的，可以在多线程环境中安全使用。

### Q: 性能如何？

A: 枚举查找使用 Stream API 遍历所有枚举值，对于图片格式这种数量有限的枚举（约 40 个），性能完全可以接受。如果在极高频率的场景下使用，可以考虑添加缓存。

## 最佳实践

1. **优先使用新 API**：使用 `fromContentType()`, `fromExtension()` 等新方法
2. **处理 null**：始终检查返回值是否为 null，或使用 Optional
3. **使用标准扩展名**：通过 `getExtension()` 获取标准化的扩展名
4. **不要硬编码**：避免直接写 "image/jpeg" 等字符串，使用枚举常量
5. **记录日志**：在类型不匹配或无法识别时记录日志，便于调试

## 相关文档

- [ImageMediaType 重构说明](IMAGE_MEDIA_TYPE_REFACTORING.md)
- [WebP 上传问题修复](WEBP_UPLOAD_FIX.md)

