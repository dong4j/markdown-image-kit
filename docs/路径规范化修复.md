# 路径规范化修复说明

## 问题描述

当配置如下时：

- `currentInsertPath = ./assets`（相对路径，以 `./` 开头）
- `preferRelativePath = false`（使用绝对路径）

粘贴图片后生成的 Markdown 标签为：

```markdown
![](/Users/dong4j/Developer/0.Worker/opensource/idea/mik/mik-test/./assets/UMVq7b.png)
```

**问题**：路径中包含了冗余的 `./`，导致路径不规范。

**预期结果**：

```markdown
![](/Users/dong4j/Developer/0.Worker/opensource/idea/mik/mik-test/assets/UMVq7b.png)
```

## 根本原因

在将相对路径转换为绝对路径时，代码使用了：

```java
File imageDir = new File(curDocument.getParent(), savepath);
String absolutePath = imageDir.getAbsolutePath();
```

当 `savepath = "./assets"` 时，`File` 对象会直接拼接路径，而 `getAbsolutePath()` 方法**不会**自动规范化路径中的 `./` 和 `../` 等相对路径标记。

## 解决方案

使用 Java 的 `File.getCanonicalPath()` 方法代替 `File.getAbsolutePath()`。

### getAbsolutePath() vs getCanonicalPath()

| 方法                   | 行为                            | 示例                                  |
|----------------------|-------------------------------|-------------------------------------|
| `getAbsolutePath()`  | 仅转换为绝对路径，**不解析** `./` 和 `../` | `/path/to/./dir` → `/path/to/./dir` |
| `getCanonicalPath()` | 转换为绝对路径，**并解析**所有相对路径标记和符号链接  | `/path/to/./dir` → `/path/to/dir`   |

### 修复内容

#### 1. PathUtils.getAbsolutePath()

**修改前**：

```java
File imageFile = new File(targetDirectory, imageName);
return normalizePathSeparator(imageFile.getAbsolutePath());
```

**修改后**：

```java
File imageFile = new File(targetDirectory, imageName);
return normalizeAndCanonicalPath(imageFile);
```

**新增方法**：

```java
private static String normalizeAndCanonicalPath(@NotNull File file) {
    try {
        // 使用 getCanonicalPath() 可以解析 "./" 和 "../" 等路径
        String canonicalPath = file.getCanonicalPath();
        return normalizePathSeparator(canonicalPath);
    } catch (Exception e) {
        // 如果无法获取规范路径，回退到绝对路径
        return normalizePathSeparator(file.getAbsolutePath());
    }
}
```

#### 2. ImageStorageHandler.saveImageToFile()

**修改前**：

```java
File imageDir = new File(curDocument.getParent(), savepath);
```

**修改后**：

```java
File imageDir = new File(curDocument.getParent(), savepath);

// 规范化目录路径，去除 "./" 等冗余部分
try {
    imageDir = imageDir.getCanonicalFile();
} catch (IOException e) {
    imageDir = imageDir.getAbsoluteFile();
}
```

## 技术细节

### getCanonicalPath() 的作用

`getCanonicalPath()` 方法会：

1. **解析相对路径标记**：
    - `./` → 当前目录，直接去除
    - `../` → 上级目录，解析并移除

2. **解析符号链接**：
    - 如果路径中包含符号链接，会解析为实际路径

3. **规范化路径分隔符**：
    - 在 Windows 上规范为 `\`
    - 在 Unix/Linux/macOS 上规范为 `/`

4. **去除冗余的路径分隔符**：
    - `//` → `/`

### 示例对比

#### 示例 1：相对路径标记

```java
File f = new File("/path/to/./directory");
f.getAbsolutePath();  // → "/path/to/./directory"
f.getCanonicalPath(); // → "/path/to/directory"
```

#### 示例 2：上级目录

```java
File f = new File("/path/to/dir/../other");
f.getAbsolutePath();  // → "/path/to/dir/../other"
f.getCanonicalPath(); // → "/path/to/other"
```

#### 示例 3：符号链接

假设 `/home/link` 是指向 `/opt/real` 的符号链接：

```java
File f = new File("/home/link/file.txt");
f.getAbsolutePath();  // → "/home/link/file.txt"
f.getCanonicalPath(); // → "/opt/real/file.txt"
```

## 测试验证

### 测试场景 1：相对路径前缀 ./

**配置**：

```
currentInsertPath: ./assets
preferRelativePath: false
```

**修复前**：

```markdown
![](/Users/user/project/./assets/image.png)
```

**修复后**：

```markdown
![](/Users/user/project/assets/image.png)
```

### 测试场景 2：相对路径前缀 ../

**配置**：

```
currentInsertPath: ../images
preferRelativePath: false
```

**当前文件**：`/Users/user/project/docs/readme.md`

**修复前**：

```markdown
![](/Users/user/project/docs/../images/image.png)
```

**修复后**：

```markdown
![](/Users/user/project/images/image.png)
```

### 测试场景 3：多级相对路径

**配置**：

```
currentInsertPath: ../../shared/images
preferRelativePath: false
```

**当前文件**：`/Users/user/project/module/docs/readme.md`

**修复前**：

```markdown
![](/Users/user/project/module/docs/../../shared/images/image.png)
```

**修复后**：

```markdown
![](/Users/user/project/shared/images/image.png)
```

## 兼容性说明

### 异常处理

`getCanonicalPath()` 可能抛出 `IOException`，主要在以下情况：

1. 文件系统不可访问
2. 权限不足
3. 路径无效

在这些情况下，代码会自动回退到 `getAbsolutePath()` 或 `getAbsoluteFile()`，确保功能不会完全失败。

### 性能影响

`getCanonicalPath()` 比 `getAbsolutePath()` 稍慢，因为它需要：

1. 访问文件系统
2. 解析符号链接
3. 验证路径存在性

但这个性能差异在图片处理的上下文中是可以忽略的。

## 相关问题

### Q1: 为什么不在设置路径时就规范化？

**A**: 因为 `currentInsertPath` 可能需要保持原始格式：

- 用户可能故意使用 `./` 来明确表示相对路径
- 在不同的上下文中，相对路径的解析结果可能不同

### Q2: 相对路径模式下需要规范化吗？

**A**: 不需要。当 `preferRelativePath = true` 时：

- 相对路径本身可能包含 `./` 和 `../`，这是正常的
- 只有在转换为绝对路径时才需要规范化

### Q3: 是否影响符号链接？

**A**: 是的，`getCanonicalPath()` 会解析符号链接。

- **优点**：得到真实的物理路径
- **注意**：如果用户依赖符号链接，路径可能与预期不同

## 总结

此修复确保了当使用绝对路径模式（`preferRelativePath = false`）时，即使 `currentInsertPath` 配置为相对路径格式（如 `./assets`
），最终生成的绝对路径也是规范化的，不包含冗余的 `./` 或 `../` 标记。

修复涉及两个文件：

1. `PathUtils.java` - 路径计算工具类
2. `ImageStorageHandler.java` - 图片存储处理器

修复后，生成的 Markdown 图片路径将更加规范和可读。

