# 绝对路径占位符修复说明

## 问题描述

当使用 `${project}` 占位符配置图片保存路径时，出现路径重复拼接的问题。

### 问题场景

**配置**：

- 项目路径：`/Users/dong4j/Developer/0.Worker/opensource/idea/mik/mik-test/`
- `currentInsertPath`：`${project}/xxx`

**预期行为**：

- 图片应该保存到：`/Users/dong4j/Developer/0.Worker/opensource/idea/mik/mik-test/xxx`

**实际行为**：

- 图片却保存到：
  `/Users/dong4j/Developer/0.Worker/opensource/idea/mik/mik-test//Users/dong4j/Developer/0.Worker/opensource/idea/mik/mik-test/xxx`
- 路径被重复拼接了两次

## 根本原因

### 路径处理流程

1. **占位符替换阶段**（在 `PasteImageAction.processPathPlaceholders()`）：
   ```
   ${project}/xxx 
   → /Users/dong4j/Developer/0.Worker/opensource/idea/mik/mik-test/xxx
   ```

2. **路径拼接阶段**（在 `ImageStorageHandler` 和 `PathUtils`）：
   ```java
   File imageDir = new File(curDocument.getParent(), savepath);
   ```

   问题：代码**没有检查 `savepath` 是否已经是绝对路径**，仍然尝试与 Markdown 文件的父目录拼接。

### 为什么会重复拼接？

虽然 Java 的 `new File(parent, child)` 构造函数在 `child` 为绝对路径时应该忽略 `parent`，但在某些情况下（可能与操作系统或文件系统实现有关），这个行为可能不符合预期。

最安全的做法是：**先检查路径是否为绝对路径，然后决定是否需要拼接**。

## 解决方案

### 修复 1：ImageStorageHandler.saveImageToFile()

**修复前**：

```java
private File saveImageToFile(...) {
    File curDocument = new File(currentFile.getPath());
    File imageDir = new File(curDocument.getParent(), savepath);  // ❌ 不检查
    // ...
}
```

**修复后**：

```java
private File saveImageToFile(...) {
    File imageDir;
    
    // ✅ 先检查 savepath 是否已经是绝对路径
    File savepathFile = new File(savepath);
    if (savepathFile.isAbsolute()) {
        // 已经是绝对路径，直接使用
        imageDir = savepathFile;
    } else {
        // 相对路径，基于 Markdown 文件的父目录拼接
        File curDocument = new File(currentFile.getPath());
        imageDir = new File(curDocument.getParent(), savepath);
    }
    // ...
}
```

### 修复 2：PathUtils.getAbsolutePath()

**修复前**：

```java
public static String getAbsolutePath(...) {
    // ...
    File targetDirectory;
    if (targetDir.startsWith("./") || targetDir.startsWith("../") 
        || !new File(targetDir).isAbsolute()) {
        targetDirectory = new File(mdParent, targetDir);
    } else {
        targetDirectory = new File(targetDir);
    }
    // ...
}
```

**修复后**：

```java
public static String getAbsolutePath(...) {
    File targetDirectory;
    
    // ✅ 先检查 targetDir 是否已经是绝对路径
    File targetDirFile = new File(targetDir);
    if (targetDirFile.isAbsolute()) {
        // 已经是绝对路径，直接使用（如使用 ${project} 占位符后）
        targetDirectory = targetDirFile;
    } else {
        // 相对路径，基于 Markdown 文件的父目录
        File mdFile = new File(markdownFile.getPath());
        File mdParent = mdFile.getParentFile();
        // ...
        targetDirectory = new File(mdParent, targetDir);
    }
    // ...
}
```

### 修复 3：PathUtils.calculateTargetRelativePath()

同样的逻辑修复，确保在处理相对路径计算时也能正确识别绝对路径。

## 修复效果

### 测试场景 1：使用 ${project} 占位符

**配置**：

```
currentInsertPath: ${project}/images
preferRelativePath: false
```

**修复前**：

```
保存路径: /project/test//project/test/images/image.png  ❌
Markdown: ![](/project/test//project/test/images/image.png)  ❌
```

**修复后**：

```
保存路径: /project/test/images/image.png  ✅
Markdown: ![](/project/test/images/image.png)  ✅
```

### 测试场景 2：使用 ${project} + 相对路径模式

**配置**：

```
currentInsertPath: ${project}/assets
preferRelativePath: true
```

**当前 Markdown 文件**：`/project/test/docs/readme.md`

**修复前**：

```
保存路径: /project/test/docs//project/test/assets/image.png  ❌
```

**修复后**：

```
保存路径: /project/test/assets/image.png  ✅
Markdown: ![](../assets/image.png)  ✅
```

### 测试场景 3：普通相对路径（不受影响）

**配置**：

```
currentInsertPath: ./imgs
preferRelativePath: true
```

**行为**：

```
修复前后行为一致：
保存路径: /current/dir/imgs/image.png  ✅
Markdown: ![](imgs/image.png)  ✅
```

## 技术细节

### File.isAbsolute() 的行为

`File.isAbsolute()` 方法在不同操作系统上的判断标准：

| 操作系统                 | 绝对路径示例                             | 相对路径示例                    |
|----------------------|------------------------------------|---------------------------|
| **Unix/Linux/macOS** | `/path/to/file`                    | `./path` `../path` `path` |
| **Windows**          | `C:\path\to\file` `\\server\share` | `.\path` `..\path` `path` |

### 占位符替换时机

占位符在 `PasteImageAction.processPathPlaceholders()` 中被替换：

```java
// 替换 ${filename} 为当前文件名（不含扩展名）
String filename = virtualFile.getNameWithoutExtension();
result = result.replace("${filename}", filename);

// 替换 ${project} 为项目根路径
if (project != null && project.getBasePath() != null) {
    String projectPath = project.getBasePath();
    result = result.replace("${project}", projectPath);
}
```

替换后的路径会通过 `state.setImageSavePath()` 传递给后续的处理器。

## IDE 文件创建限制说明

### 问题："IDE 是否限制在项目外创建文件？"

**答案：不是 IDE 的限制**。

IDE（IntelliJ IDEA）本身**不限制**插件在项目外部创建文件，只要：

1. 路径有效
2. 有写入权限
3. 父目录存在或可创建

本次问题的原因是**路径拼接逻辑错误**，而不是 IDE 的限制。

### 验证方法

你可以配置 `currentInsertPath` 为绝对路径（不使用 ${project}）来测试：

```
currentInsertPath: /Users/dong4j/Downloads/test-images
```

如果修复后的代码工作正常，图片会被保存到 Downloads 目录（项目外部）。

## 占位符使用建议

### ${project} 占位符

**适用场景**：

- 希望图片保存在项目根目录的某个子目录
- 多个 Markdown 文件需要共享同一个图片目录

**示例**：

```
${project}/docs/images    → 保存到项目根目录下的 docs/images
${project}/.assets        → 保存到项目根目录下的 .assets（隐藏目录）
```

### ${filename} 占位符

**适用场景**：

- 每个 Markdown 文件有自己的图片目录
- 文件名即为图片目录名

**示例**：

```
./${filename}.assets      → ./readme.assets（当前文件名为 readme.md）
${project}/docs/${filename}  → /project/docs/readme（结合 project 使用）
```

### 组合使用

```
${project}/docs/${filename}/images
```

如果当前文件为 `tutorial.md`，项目路径为 `/my/project`，则图片保存到：

```
/my/project/docs/tutorial/images
```

## 相关问题

### Q1: 为什么不在占位符替换时就检查？

**A**: 占位符替换是在 `PasteImageAction` 中进行的，此时还不知道后续会如何使用这个路径（相对路径计算 vs 绝对路径拼接）。在使用路径的地方检查更加合适。

### Q2: 如果使用了不存在的项目路径怎么办？

**A**: 代码会尝试创建目录：

```java
if (!checkDir && !imageDir.mkdirs()) {
    return null;  // 创建失败
}
```

### Q3: ${project} 占位符在子模块中如何工作？

**A**: `project.getBasePath()` 返回的是项目的根目录，对于多模块项目：

- 如果在子模块中打开，返回子模块的根目录
- 如果在主项目中打开，返回主项目的根目录

## 测试验证清单

- [ ] 测试 `${project}/xxx` + `preferRelativePath = false`
- [ ] 测试 `${project}/xxx` + `preferRelativePath = true`
- [ ] 测试 `${filename}.assets` 占位符
- [ ] 测试组合占位符 `${project}/docs/${filename}`
- [ ] 测试绝对路径（项目外部）
- [ ] 测试普通相对路径 `./imgs`（确保不受影响）
- [ ] 在 Windows 上测试（如果可能）

## 总结

此修复解决了使用 `${project}` 等占位符时路径重复拼接的问题。核心改进是：

1. ✅ 在拼接路径之前，先检查路径是否已经是绝对路径
2. ✅ 如果是绝对路径，直接使用，不再拼接
3. ✅ 如果是相对路径，才基于父目录拼接

这不是 IDE 的限制，而是路径处理逻辑的 bug。修复后，你可以自由使用占位符配置任意位置的保存路径。

